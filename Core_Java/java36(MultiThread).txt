Q)Types of Data structure in java?

Diagram: java36.1


Q)Write a java program to display unique and duplicate elments from given array?

Input:
	5 1 2 3 3 9 1 7 6 4 4 3 

output:

	Unique : 5 1 2 3 9 7 6 4 

	Duplicates : 1 3 4 

ex:
---
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		int[] arr={5,1,2,3,3,9,1,7,6,4,4,3};

		Set<Integer> duplicate=new LinkedHashSet<Integer>();
		Set<Integer> unique=new LinkedHashSet<Integer>();

		//for each loop
		for(int ele:arr)
		{
			if(!unique.add(ele))
			{
				duplicate.add(ele);
			}
			unique.add(ele);
		}

		System.out.println("Unique : "+unique);
		System.out.println("Duplicate :"+duplicate);
	}
}


Q)Write a java program to display unique elments from given array?

Input:
	5 1 2 3 3 9 1 7 6 4 4 3 

output:

	5 1 2 3 9 7 6 4 

ex:

import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		int[] arr={5,1,2,3,3,9,1,7,6,4,4,3};

		Set<Integer> unique=new LinkedHashSet<Integer>();

		//for each loop
		for(int ele:arr)
		{
			unique.add(ele); // 5 1 2 3 9 7 6 4
		}
		
		//converting collection to array 
		int[] resArr=new int[unique.size()];	
		int j=0;
		for(Integer i:unique)
		{
			resArr[j++]=i;	
		}

		//display
		for(int ele:resArr)
		{
			System.out.print(ele+" ");
		}
	}
}


Multithreading
===============

Q)What is the difference between Thread and Process?

Thread
-------
A thread is a leight weight sub-process.
We can run multiple threads concurently.
One thread can communicate with another thread.
ex:
	In java a class is one thread
	In java a constructor is one thread
	In java a block is one thread 

Process
-------
A process is a collection of threads.
We can run multiple process concurently.
One process can't communicate with another process because it is independent.
ex:
	Taking a java class by using zoom meeting is one process
	Downloading a file from internet is one process
	typing the notes in editor is one process

Multitasking
==============
Executing several task simultenously such concept is called multitasking.

We have two types of multitasking.

1)Process based multitasking 
---------------------------
Executing several task simultenously where each task is a independent process such types of multitasking is called process based multitasking.

2)Thread based multitasking 
--------------------------
Executing several task simultenously where each task is a same part of a program such type of multitasking is called thread based multitasking.

Multithreading
===============
Executing several threads simultenously such concept is called multithreading.

In multithreading only 10% of work should be done by a programmer and 90% of work will be done by a JAVA API.

The main important application area of multithreading are.

1) To implements multimedia graphics.

2) To develop video games 

3) To develop animations.


Ways to create a thread in java
================================
There are two ways to create or start or instantiate a thread in java.

1)By extending Thread class 

2)By implementing Runnable interface 

1)By extending Thread class 
---------------------------
class MyThread extends Thread 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
		}
	}
}
class Test
{
	public static void main(String[] args)
	{
		//instantitate a thread 
		MyThread t=new MyThread();
		
		//start a thread 
		t.start();

		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}

case1: Thread Schedular
-------------------------
If multiple threads are waiting for execution which thread will execute will decide by thread schedular.

What algorithm, behaviour and mechanism used by thread schedular is depends upon JVM vendor.

Hence we can't expect any execution order or exact output in multithreading.


case2: Difference between t.start() and t.run()
----------------------------------------------
If we invoke t.start() method then a new object will created which is responsible to execute run() method automatically.

ex:

class MyThread extends Thread 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
		}
	}
}
class Test
{
	public static void main(String[] args)
	{
		//instantitate a thread 
		MyThread t=new MyThread();
		
		//start a thread 
		t.start();

		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}

If we invoke t.run() method then no new thread will be created but run() method will execute just like normal method.

ex:

class MyThread extends Thread 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
		}
	}
}
class Test
{
	public static void main(String[] args)
	{
		//instantitate a thread 
		MyThread t=new MyThread();
		
		//no new thread	
		t.run();

		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}

case3: If we won't override run() method
---------------------------------------
If we won't override run() method then t.start() method will execute Thread class run() method  automatically.

Thread class run() method is a empty implementation.

ex:

class MyThread extends Thread 
{
	
}
class Test
{
	public static void main(String[] args)
	{
		//instantitate a thread 
		MyThread t=new MyThread();
		
		//new thread 
		t.start();

		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}

case4: If we overload run() method
---------------------------------
If we overload run() method then t.start() method always execute run() method with 0-argument method.

ex:

class MyThread extends Thread 
{
	public void run()
	{
		System.out.println("0-arg method");
	}
	public void run(int i)
	{
		System.out.println("int-arg method");
	}
}
class Test
{
	public static void main(String[] args)
	{
		//instantitate a thread 
		MyThread t=new MyThread();
		
		//new thread 
		t.start();

		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}

case5: Life cycle of a thread
-----------------------------

Once if we create a thread object then our thread will be in new or born state.

Once if we call t.start() method then our thread goes to ready/runnable state.

If Thread schedular allocates to CPU then out thread enters to running state.

Once the run() method execution is completed then our thread goes to dead state.

Diagram: java36.2

2)By implementing Runnable interface 
------------------------------------
class MyRunnable implements Runnable 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
		}
	}
}
class Test
{
	public static void main(String[] args)
	{
		 MyRunnable r=new  MyRunnable();
		
		Thread t=new Thread(r); // r is a targatable interface	

		t.start();

		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}

Setting and Getting name of a thread
=====================================
In java , every thread has a name explicitly provided by the programmer and automatically generated by JVM.

We have following methods to set and get name of a thread.

ex:
	public final void setName(String name);
	public final String getName();

ex:

class MyThread extends Thread 
{
}
class Test
{
	public static void main(String[] args)
	{
		System.out.println(Thread.currentThread().getName());//main 

		MyThread t=new MyThread();
		System.out.println(t.getName());//Thread-0

		Thread.currentThread().setName("Parent-Thread");
		System.out.println(Thread.currentThread().getName());//Parent-Thread

		t.setName("Child-Thread");
		System.out.println(t.getName());//Child-Thread
	}
}

Thread priority
===============
In java, every thread has a priority explicitly provided by the programmer or automatically generated by JVM.

The valid range of thread priority is 1 to 10.Where 1 is a least priority and 10 is a highest priority.

Thread class defines following constants as a thread priority.
ex:
	Thread.MAX_PRIORITY  - 10
	Thread.MIN_PRIORITY  - 1 
	Thread.NORM_PRIORITY - 5

We don't have such constants like LOW_PRIORITY and HIGH_PRIORITY.

A thread which is having highest priority will be executed first.

Thread schedular uses thread priority while allocating to CPU.

If multiple threads having same priority then we can't expect any execution order.

If we take more then 10 priority then we will get IllegalArgumentException.

We have following methods to set and get thread priority.

ex:
	public final void setPriority(int priority);
	public final int getPriority();

ex:

class MyThread extends Thread 
{
}
class Test
{
	public static void main(String[] args)
	{
		System.out.println(Thread.currentThread().getPriority());//5

		MyThread t=new MyThread();
		System.out.println(t.getPriority());//5

		Thread.currentThread().setPriority(9);
		System.out.println(Thread.currentThread().getPriority());//9

		t.setPriority(4);
		System.out.println(t.getPriority());//4
	}
}





















	


























