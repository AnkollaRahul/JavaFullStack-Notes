LinkedList 
===========
The underlying data structure is double linkedlist.

Duplicate objects are allowed.

Order is preserved.

Hetrogeneous objects are allowed.

Null insertion is possible.

It implements Serializable, Cloneable and Deque interface.

If our frequent operation is a adding and removing in the middle then LinkedList is a best choice.

LinkedList contains following methods.

ex:
	addFirst()
	addLast()
	getFirst()
	getLast()
	removeFirst()
	removeLast()
	and etc.

ex:
----
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		LinkedList ll=new LinkedList();
		ll.add("one");
		ll.add("two");
		ll.add("three");
		System.out.println(ll);//[one,two,three]
		ll.add("one");
		System.out.println(ll);//[one,two,three,one]
		ll.add(10);
		System.out.println(ll);//[one,two,three,one,10]
		ll.add(null);
		System.out.println(ll);//[one,two,three,one,10,null]
	}
}

ex:
----
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		LinkedList<String> ll=new LinkedList<String>();
		ll.add("one");
		ll.add("two");
		ll.add("three");
		System.out.println(ll);//[one,two,three]
		ll.addFirst("gogo");
		ll.addLast("jojo");
		System.out.println(ll);//[gogo,one,two,three,jojo]

		System.out.println(ll.getFirst());//gogo
		System.out.println(ll.getLast());//jojo

		ll.removeFirst();
		ll.removeLast();
		System.out.println(ll);//[one,two,three]
	}
}

ex:
----
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		LinkedList<String> ll1=new LinkedList<String>();
		ll1.add("one");
		ll1.add("two");
		ll1.add("three");
		System.out.println(ll1);//[one,two,three]

		LinkedList<String> ll2=new LinkedList<String>();
		ll2.add("raja");
		System.out.println(ll2);//[raja]

		ll2.addAll(ll1);
		System.out.println(ll2);//[raja,one,two,three]

		System.out.println(ll2.containsAll(ll1));// true 

		ll2.removeAll(ll1);
		System.out.println(ll2);//[raja]
	}
}

Vector
======
The underlying data structure is resizable array or growable array.

Duplicate objects are allowed.

Insertion order is preserved.

Hetrogeneous objects are allowed.

Null insertion is possible.

It implements Serializable, Cloneable and RandomAccess interface.

All the methods present in Vector are synchronized.Hence we can achieve thread safety.

Vector contains following methods.

ex:
	addElement()
	firstElement()
	lastElement()
	removeElementAt()
	removeAllElements()
	and etc.

ex:
----
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		Vector v=new Vector();
		v.add("one");
		v.add("two");
		v.add("three");
		System.out.println(v);//[one,two,three]
		v.add("one");
		System.out.println(v);//[one,two,three,one]
		v.add(10);
		System.out.println(v);//[one,two,three,one,10]
		v.add(null);
		System.out.println(v);//[one,two,three,one,10,null]

	}
}

ex:
---
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		Vector v=new Vector();
		v.addElement("one");
		v.addElement("two");
		v.addElement("three");
		System.out.println(v);//[one,two,three]

		System.out.println(v.firstElement());//one
		System.out.println(v.lastElement());//three

		v.removeElementAt(1);
		System.out.println(v);//[one,three]

		v.removeAllElements();
		System.out.println(v);//[]

	}
}

ex:
---
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		Vector v=new Vector();
		v.add("one");
		v.add("two");
		v.add("three");
		System.out.println(v);//[one,two,three]

		System.out.println(v.get(0));//one
		System.out.println(v.get(v.size()-1));//three

		v.remove("two");
		System.out.println(v);//[one,three]

		v.clear();
		System.out.println(v);//[]

	}
}

Stack
======
It is a child class of Vector class.

If we depends upon Last In First Out (LIFO) order then we need to use Stack.

We can create Stack object as follow.

ex:
	Stack	s =new Stack();

Methods
---------
1) push(Object o)
-----------------
	It will insert the element to stack.

2) pop()
--------
	It will remove the element from stack.

3) peek()
---------
	It will return toppest element of stack.

4) isEmpty()
--------
	It is used to check stack is empty or not.

5) search(Object o)
---------------
	It will return offset value if element is found otherwiser it will 
	return -1.

ex:
----
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		Stack<String> s=new Stack<String>();
		s.push("A");
		s.push("B");
		s.push("C");
		System.out.println(s);//[A,B,C]

		s.pop();
		System.out.println(s);//[A,B]

		System.out.println(s.peek());//B

		System.out.println(s.isEmpty());//false

		System.out.println(s.search("Z")); // -1

		System.out.println(s.search("A"));//2
	}
}

Set
=====
It is a child interface of Collection interface.

If we want to represent group of individual objects in a single entity where duplicate objects are not allowed and order is not preserved then we need to use Set interface.

Diagram: java34.1



HashSet
========
The underlying data structure is Hashtable.

Duplicate objects are not allowed.

Order is not preserved because it will take hash code of an object.

Hetrogeneous objects are allowed.

Null insertion is possible.

ex:
---
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		HashSet hs=new HashSet();
		hs.add("one");
		hs.add("nine");
		hs.add("five");
		hs.add("eight");
		System.out.println(hs);//[nine, one, five, eight]
		hs.add("one");
		System.out.println(hs);//[nine,one,five,eight]
		hs.add(10);
		System.out.println(hs);//[nine, one, 10, five, eight]
		hs.add(null);
		System.out.println(hs);//[null, nine, one, 10, five, eight]
	}
}

ex:
--
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		HashSet<String> hs=new HashSet<String>();
		hs.add("one");
		hs.add("nine");
		hs.add("five");
		hs.add("eight");
		System.out.println(hs);//[nine, one, five, eight]
		hs.add("one");
		System.out.println(hs);//[nine,one,five,eight]
		hs.add(null);
		System.out.println(hs);//[null, nine, one, five, eight]
	}
}

LinkedHashSet 
==============
LinkedHashSet is a child class of HashSet class.

LinkedHashSet is exactly same as HashSet class with following differences.

HashSet					LinkedHashSet
---------				-----------
The underlying data structure 		The underlying data structure is 
is Hashtable. 				Hashtable and LinkedList.

Insertion order is not preserved.	Insertion order is preserved.

It is introduced in 1.2v.		It is introduced in 1.4v.

ex:

import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		LinkedHashSet<String> lhs=new LinkedHashSet<String>();
		lhs.add("one");
		lhs.add("nine");
		lhs.add("five");
		lhs.add("eight");
		System.out.println(lhs);//[one,nine,five,eight]
		lhs.add("one");
		System.out.println(lhs);//[one,nine,five,eight]
		lhs.add(null);
		System.out.println(lhs);//[one,nine,five,eight,null]
	}
}

TreeSet
=======
The underlying data structure is Balanced Tree.

Duplicate objects are not allowed.

Insertion order is not preserved because it will take sorting order of an object.

Hetrogenous objects are not allowed if we insert then we will get ClassCastException.

For empty TreeSet if we trying to insert null then we will get NullPointerException.

After inserting the elements if we are trying to insert null then we will get NullPointerException.

ex:
---
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		TreeSet ts=new TreeSet();
		ts.add(10);
		ts.add(1);
		ts.add(5);
		ts.add(7);
		ts.add(3);
		System.out.println(ts);//[1,3,5,7,10]
		ts.add(10);
		System.out.println(ts);//[1,3,5,7,10]
		//ts.add("hi");
		//System.out.println(ts);//R.E ClassCastException
		//ts.add(null);
		//System.out.println(ts);// R.E NullPointerException

	}
}

Q)What is the difference between Comparable and Comparator interface.

Comparable
----------
Comparable interface present in java.lang package.

It contains only one method i.e compareTo() method.

ex:
	compareTo(Object obj1,Object obj2);

	It will return -ve if obj1 comes before obj2.
	It will return +ve if obj1 comes after obj2.
	it will return 0 if both objects are same.

If we depend upon default natural sorting then we need to use Comparable interface.

ex:
---
	
class Test  
{
	public static void main(String[] args) 
	{
		System.out.println("A".compareTo("Z"));	//-25
		
		System.out.println("Z".compareTo("A")); // 25

		System.out.println("K".compareTo("K")); // 0

	}
}

Comparator
------------
Comparator is an interface which is present in java.util package.

Comparator interface contains following two methods. i.e equals() and 
compare() method.
ex:
	 public abstract int compare(Object obj1, Object obj2);
	 	
		It will return +ve if obj1 comes before obj2.
		It will return -ve if obj1 comes after obj2.
		It will return 0 if both objects are same.
 	
	 public abstract boolean equals(java.lang.Object);

Implementation of equals() method is optional because it is present in Object class so it is available through inheritance.

Implementation of compare() method is mandatory.

If we depends upon customized sorting order then we need to use Comparator interface.


ex:
--
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		TreeSet<Integer> ts=new TreeSet<Integer>(new MyComparator());
		ts.add(10);
		ts.add(1);
		ts.add(5);
		ts.add(7);
		ts.add(3);
		System.out.println(ts);//10 7 5 3 1
	}
}
class MyComparator implements Comparator  
{
	public int compare(Object obj1,Object obj2)
	{
		Integer i1=(Integer)obj1;
		Integer i2=(Integer)obj2;
		if(i1<i2)
			return 1;
		else if(i1>i2)
			return -1;
		else 
			return 0;
	}
}

ex:
---
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		TreeSet<Integer> ts=new TreeSet<Integer>(new MyComparator());
		ts.add(10);
		ts.add(1);
		ts.add(5);
		ts.add(7);
		ts.add(3);
		System.out.println(ts);//1 3 5 7 10
	}
}
class MyComparator implements Comparator  
{
	public int compare(Object obj1,Object obj2)
	{
		Integer i1=(Integer)obj1;
		Integer i2=(Integer)obj2;
		if(i1<i2)
			return -1;
		else if(i1>i2)
			return 1;
		else 
			return 0;
	}
}


























































































































































































































